# Docker Shenanigans

## Installing Docker

Follow official guide: <https://docs.docker.com/engine/install/ubuntu/>

## Post Install setup

```bash
   sudo groupadd docker
   sudo usermod -aG docker $USER
   newgrp docker
   docker run hello-world
```

## Running Docker containers

In the root directory of the app (where the /src folder resides together with `Dockerfile` and `docker-compose.yml`):

1. Build (and rebuild after a `git pull`) image

   ```bash
   docker-compose build
   ```

2. Build container

   ```bash
   docker-compose up
   ```

3. Stop container

   ```bash
   docker-compose stop
   ```

4. Start container

   ```bash
   docker-compose start
   ```

5. Delete container

   ```bash
   docker-compose down
   ```

6. To run a `shell` session from within a container:

   ```bash
   docker exec -it container_name sh
   ```

   or

   ```bash
   docker compose exec -it container_name sh
   ```

Prefer to use `docker-compose` instead of plain `docker` because of potential to bundle apps together in the same service if needed.

Somehow the browser caches locally websites hosted on docker. Need to use incognito mode to check if website is refreshed properly.

## Random running out of space

If use Docker too much, might have issues with disk space on `/Home` folder.

Do a clean up (<https://askubuntu.com/questions/57994/root-drive-is-running-out-of-disk-space-how-can-i-free-up-space>):

```bash
docker system prune
```

Or

```bash
docker system prune -af --volumes
```

## CI/CD workflow using Github Actions and self-hosted runner

1. At repo side: `"Actions"` -> `"Nodejs"`.
   At autogenerated workflow yaml file, modify the `runs-on` variable to be `self-hosted`
   Commit and push to main.
   Still at repo side: `"Settings"` -> `"Add Runner"` -> Follow instructions to install runner at server side.
2. At server side hosting the app: continuing from last step of first part above, when following the instructions to create a `"actions-runner"` folder, the folder can be named anything. For me I name it within an `"automated-repos"` folder, and name the actions runner folder using the project name.
   Then:

   ```bash
   ./run.sh
   ```

   Once app is running ok, chut it down and install the runner as a `systemctl` service:

   ```bash
   sudo ./svc.sh install
   sudo ./svc.sh start
   ```

Dockerfile for simple `create-react-app` app to run production build:

```Dockerfile
FROM node:20

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD ["npx", "serve", "build"]
```

`docker-compose.yaml`:

```yaml
version: "3"
services:
  [REPLACE WITH APP NAME]:
    build: .
    pull_policy: build
    restart: always
    ports:
      - "3000:3000"
```

`.github/workflows/node.js.yml`:

```yaml
name: Node.js CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  build:
    runs-on: self-hosted

    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"
      - run: docker-compose down
      - run: docker-compose build
      - run: docker-compose up --no-start
      - run: docker-compose start
```

Alternatively, can replace above docker commands with one: `docker-compose up -d --build`. This command will not delete the old container, but instead will build it then run it in detached mode. <https://stackoverflow.com/questions/42529211/how-to-rebuild-and-update-a-container-without-downtime-with-docker-compose>

Will need to relook into above workflow file naming, because it seems the workflow is mainly deploying Docker containers rather than pure Nodejs service.
